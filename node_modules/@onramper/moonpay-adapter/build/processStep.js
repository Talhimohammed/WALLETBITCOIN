"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const token_1 = require("./utils/token");
const errors_1 = require("./errors");
const KYC_1 = require("./KYC");
const items = __importStar(require("./KYC/items"));
const getNextKYCStepFromTxIdAndToken_1 = __importDefault(require("./KYC/getNextKYCStepFromTxIdAndToken"));
const registerBank_1 = __importDefault(require("./registerBank"));
const sendWaypoint_1 = __importDefault(require("./sendWaypoint"));
const index_1 = require("./index");
// Separated cause it's too bulky
function processIdentityState(tokenValues, body, onramperApiKey) {
    if (!token_1.checkTokenTypes(tokenValues, ["", "", "", 0, 0, 0, "", "", "", ""])) {
        throw new errors_1.StepError("URL is incorrect.", null);
    }
    const [id, firstName, lastName, day, month, year, street, town, postCode, providedCountry,] = tokenValues;
    token_1.checkBodyParams(body, [items.stateItem]);
    const state = body[items.stateItem.name];
    if (state === "") {
        throw new errors_1.StepError(`Parameter ${items.stateItem.name} must not be empty.`, items.stateItem.name);
    }
    return KYC_1.registerIdentity(id, onramperApiKey, firstName, lastName, { day, month, year }, street, town, postCode, body[items.stateItem.name], providedCountry);
}
function default_1(step, token, body, onramperApiKey, country) {
    let tokenValues;
    try {
        tokenValues = token_1.decodeToken(token);
    }
    catch (e) {
        throw new errors_1.StepError("URL is incorrect.", null);
    }
    if (step !== "email" &&
        step !== "identity" &&
        step !== "registerCreditCardToken") {
        sendWaypoint_1.default(tokenValues[0].toString(), onramperApiKey, step, {});
    }
    if (step === "email") {
        index_1.setPartnerContext(body.partnerContext);
        if (!token_1.checkTokenTypes(tokenValues, [
            "",
            0,
            "",
            "",
            "",
        ])) {
            throw new errors_1.StepError("URL is incorrect.", null);
        }
        const [id, amount, fiatCurrency, cryptoCurrency, paymentMethod,] = tokenValues;
        token_1.checkBodyParams(body, [
            items.emailItem,
            items.cryptocurrencyAddress,
            items.cryptocurrencyAddressTag,
        ]);
        return KYC_1.registerEmail(id, amount, fiatCurrency, cryptoCurrency, paymentMethod, onramperApiKey, body[items.emailItem.name], body[items.cryptocurrencyAddress.name], body[items.cryptocurrencyAddressTag.name], country);
    }
    if (step === "verifyEmail") {
        if (!token_1.checkTokenTypes(tokenValues, ["", ""])) {
            throw new errors_1.StepError("URL is incorrect.", null);
        }
        const [id, email] = tokenValues;
        token_1.checkBodyParams(body, [items.verifyEmailCodeItem]);
        return KYC_1.verifyEmail(id, email, body[items.verifyEmailCodeItem.name], onramperApiKey, country);
    }
    if (step === "identity") {
        if (!token_1.checkTokenTypes(tokenValues, [""])) {
            throw new errors_1.StepError("URL is incorrect.", null);
        }
        const [id] = tokenValues;
        token_1.checkBodyParams(body, [
            items.firstNameItem,
            items.lastNameItem,
            items.dateOfBirthItem,
            items.streetItem,
            items.townItem,
            items.postCodeItem,
            items.countryItem,
        ]); // Doesn't include 'state', it's optional
        return KYC_1.registerIdentity(id, onramperApiKey, body[items.firstNameItem.name], body[items.lastNameItem.name], body[items.dateOfBirthItem.name], body[items.streetItem.name], body[items.townItem.name], body[items.postCodeItem.name], body[items.stateItem.name], body[items.countryItem.name]);
    }
    if (step === "identityState") {
        return processIdentityState(tokenValues, body, onramperApiKey);
    }
    if (step === "getNextKYCStep") {
        if (!token_1.checkTokenTypes(tokenValues, ["", ""])) {
            throw new errors_1.StepError("URL is incorrect.", null);
        }
        const [id, csrfToken] = tokenValues;
        return getNextKYCStepFromTxIdAndToken_1.default(id, csrfToken, onramperApiKey);
    }
    if (step === "registerPhone") {
        if (!token_1.checkTokenTypes(tokenValues, ["", ""])) {
            throw new errors_1.StepError("URL is incorrect.", null);
        }
        const [id, csrfToken] = tokenValues;
        token_1.checkBodyParams(body, [items.phoneCountryCodeItem, items.phoneNumberItem]);
        return KYC_1.registerPhone(id, csrfToken, body[items.phoneCountryCodeItem.name], body[items.phoneNumberItem.name]);
    }
    if (step === "verifyPhone") {
        if (!token_1.checkTokenTypes(tokenValues, ["", ""])) {
            throw new errors_1.StepError("URL is incorrect.", null);
        }
        const [id, csrfToken] = tokenValues;
        token_1.checkBodyParams(body, [items.verifyPhoneCodeItem]);
        return KYC_1.verifyPhone(id, csrfToken, body[items.verifyPhoneCodeItem.name], onramperApiKey);
    }
    if (step === "registerBank") {
        if (!token_1.checkTokenTypes(tokenValues, ["", "", ""])) {
            throw new errors_1.StepError("URL is incorrect.", null);
        }
        const [id, csrfToken, fiatCurrency] = tokenValues;
        if (fiatCurrency === "EUR") {
            token_1.checkBodyParams(body, [items.bankIbanItem]);
            return registerBank_1.default(id, csrfToken, {
                currencyCode: "eur",
                iban: body[items.bankIbanItem.name],
            });
        }
        if (fiatCurrency === "GBP") {
            token_1.checkBodyParams(body, [
                items.bankSortCodeItem,
                items.bankAccountNumberItem,
            ]);
            return registerBank_1.default(id, csrfToken, {
                currencyCode: "gbp",
                accountNumber: body[items.bankAccountNumberItem.name],
                sortCode: body[items.bankSortCodeItem.name],
            });
        }
        throw new errors_1.StepError("URL is incorrect, unaccepted fiat currency.", null);
    }
    if (step === "registerCreditCardToken") {
        throw new errors_1.StepError(`The last step of the credit card flow, 'registerCreditCardToken', should not be called through the default method, instead it should be called with the function 'finishCCTransaction' that is directly exported from the package. Check the package's readme for more details.`, null);
    }
    throw new errors_1.StepError(`Step '${step}' is not defined for Moonpay.`, null);
}
exports.default = default_1;
