{"version":3,"file":"index.js","sources":["../src/helpers.ts","../src/configuration.ts","../src/controller.ts","../src/resolver.ts","../src/logParser.ts"],"sourcesContent":["import { getAddress } from '@ethersproject/address'\nimport { BigNumber } from '@ethersproject/bignumber'\nimport { computeAddress } from '@ethersproject/transactions'\nimport { VerificationMethod } from 'did-resolver'\n\nexport const identifierMatcher = /^(.*)?(0x[0-9a-fA-F]{40}|0x[0-9a-fA-F]{66})$/\nexport const nullAddress = '0x0000000000000000000000000000000000000000'\nexport const DEFAULT_REGISTRY_ADDRESS = '0xdca7ef03e98e0dc2b855be647c39abe984fcf21b'\nexport const DEFAULT_JSON_RPC = 'http://127.0.0.1:8545/'\n\nexport type address = string\nexport type uint256 = BigNumber\nexport type bytes32 = string\nexport type bytes = string\n\nexport interface ERC1056Event {\n  identity: address\n  previousChange: uint256\n  validTo?: uint256\n  _eventName: string\n}\n\nexport interface DIDOwnerChanged extends ERC1056Event {\n  owner: address\n}\n\nexport interface DIDAttributeChanged extends ERC1056Event {\n  name: bytes32\n  value: bytes\n  validTo: uint256\n}\n\nexport interface DIDDelegateChanged extends ERC1056Event {\n  delegateType: bytes32\n  delegate: address\n  validTo: uint256\n}\n\nexport enum verificationMethodTypes {\n  EcdsaSecp256k1VerificationKey2019 = 'EcdsaSecp256k1VerificationKey2019',\n  EcdsaSecp256k1RecoveryMethod2020 = 'EcdsaSecp256k1RecoveryMethod2020',\n  Ed25519VerificationKey2018 = 'Ed25519VerificationKey2018',\n  RSAVerificationKey2018 = 'RSAVerificationKey2018',\n  X25519KeyAgreementKey2019 = 'X25519KeyAgreementKey2019',\n}\n\nexport enum eventNames {\n  DIDOwnerChanged = 'DIDOwnerChanged',\n  DIDAttributeChanged = 'DIDAttributeChanged',\n  DIDDelegateChanged = 'DIDDelegateChanged',\n}\n\nexport interface LegacyVerificationMethod extends VerificationMethod {\n  /**@deprecated */\n  publicKeyHex?: string\n  /**@deprecated */\n  publicKeyBase64?: string\n  /**@deprecated */\n  publicKeyPem?: string\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  [x: string]: any\n}\n\nexport const legacyAttrTypes: Record<string, string> = {\n  sigAuth: 'SignatureAuthentication2018',\n  veriKey: 'VerificationKey2018',\n  enc: 'KeyAgreementKey2019',\n}\n\nexport const legacyAlgoMap: Record<string, string> = {\n  /**@deprecated */\n  Secp256k1VerificationKey2018: verificationMethodTypes.EcdsaSecp256k1VerificationKey2019,\n  /**@deprecated */\n  Ed25519SignatureAuthentication2018: verificationMethodTypes.Ed25519VerificationKey2018,\n  /**@deprecated */\n  Secp256k1SignatureAuthentication2018: verificationMethodTypes.EcdsaSecp256k1VerificationKey2019,\n  //keep legacy mapping\n  RSAVerificationKey2018: verificationMethodTypes.RSAVerificationKey2018,\n  Ed25519VerificationKey2018: verificationMethodTypes.Ed25519VerificationKey2018,\n  X25519KeyAgreementKey2019: verificationMethodTypes.X25519KeyAgreementKey2019,\n}\n\nexport function bytes32toString(input: bytes32 | Uint8Array): string {\n  const buff: Buffer = typeof input === 'string' ? Buffer.from(input.slice(2), 'hex') : Buffer.from(input)\n  return buff.toString('utf8').replace(/\\0+$/, '')\n}\n\nexport function stringToBytes32(str: string): string {\n  const buffStr = '0x' + Buffer.from(str).slice(0, 32).toString('hex')\n  return buffStr + '0'.repeat(66 - buffStr.length)\n}\n\nexport function interpretIdentifier(identifier: string): { address: string; publicKey?: string } {\n  if (identifier.length > 42) {\n    return { address: computeAddress(identifier), publicKey: identifier }\n  } else {\n    return { address: getAddress(identifier) } // checksum address\n  }\n}\n\nconst knownInfuraNetworks: Record<string, string> = {\n  mainnet: '0x1',\n  ropsten: '0x3',\n  rinkeby: '0x4',\n  goerli: '0x5',\n  kovan: '0x2a',\n}\n\nexport const knownNetworks: Record<string, string> = {\n  ...knownInfuraNetworks,\n}\n","import { BigNumber } from '@ethersproject/bignumber'\nimport { Contract, ContractFactory } from '@ethersproject/contracts'\nimport { InfuraProvider, JsonRpcProvider, Provider } from '@ethersproject/providers'\nimport DidRegistryContract from 'ethr-did-registry'\nimport { DEFAULT_REGISTRY_ADDRESS, knownNetworks } from './helpers'\n\n/**\n * A configuration entry for an ethereum network\n * It should contain at least one of `name` or `chainId` AND one of `provider`, `web3`, or `rpcUrl`\n *\n * @example ```js\n * { name: 'development', registry: '0x9af37603e98e0dc2b855be647c39abe984fc2445', rpcUrl: 'http://127.0.0.1:8545/' }\n * { name: 'goerli', chainId: 5, provider: new InfuraProvider('goerli') }\n * { name: 'rinkeby', provider: new AlchemyProvider('rinkeby') }\n * { name: 'rsk:testnet', chainId: '0x1f', rpcUrl: 'https://public-node.testnet.rsk.co' }\n * ```\n */\nexport interface ProviderConfiguration {\n  name?: string\n  provider?: Provider\n  rpcUrl?: string\n  registry?: string\n  chainId?: string | number\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  web3?: any\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  [index: string]: any\n}\n\nexport interface MultiProviderConfiguration extends ProviderConfiguration {\n  networks?: ProviderConfiguration[]\n}\n\nexport interface InfuraConfiguration {\n  infuraProjectId: string\n}\n\nexport type ConfigurationOptions = MultiProviderConfiguration | InfuraConfiguration\n\nexport type ConfiguredNetworks = Record<string, Contract>\n\nfunction configureNetworksWithInfura(projectId?: string): ConfiguredNetworks {\n  if (!projectId) {\n    return {}\n  }\n  const networks: ProviderConfiguration[] = [\n    { name: 'mainnet', chainId: '0x1', provider: new InfuraProvider('homestead', projectId) },\n    { name: 'ropsten', chainId: '0x3', provider: new InfuraProvider('ropsten', projectId) },\n    { name: 'rinkeby', chainId: '0x4', provider: new InfuraProvider('rinkeby', projectId) },\n    { name: 'goerli', chainId: '0x5', provider: new InfuraProvider('goerli', projectId) },\n    { name: 'kovan', chainId: '0x2a', provider: new InfuraProvider('kovan', projectId) },\n  ]\n  return configureNetworks({ networks })\n}\n\nfunction getContractForNetwork(conf: ProviderConfiguration): Contract {\n  let provider: Provider = conf.provider || conf.web3?.currentProvider\n  if (!provider) {\n    if (conf.rpcUrl) {\n      const chainId = conf.chainId ? BigNumber.from(conf.chainId).toNumber() : conf.chainId\n      const networkName = knownNetworks[conf.name || ''] ? conf.name?.replace('mainnet', 'homestead') : 'any'\n      provider = new JsonRpcProvider(conf.rpcUrl, chainId || networkName)\n    } else {\n      throw new Error(`invalid_config: No web3 provider could be determined for network ${conf.name || conf.chainId}`)\n    }\n  }\n  const contract: Contract = ContractFactory.fromSolidity(DidRegistryContract)\n    .attach(conf.registry || DEFAULT_REGISTRY_ADDRESS)\n    .connect(provider)\n  return contract\n}\n\nfunction configureNetwork(net: ProviderConfiguration): ConfiguredNetworks {\n  const networks: ConfiguredNetworks = {}\n  const chainId = net.chainId || knownNetworks[net.name || '']\n  if (chainId) {\n    if (net.name) {\n      networks[net.name] = getContractForNetwork(net)\n    }\n    const id = typeof chainId === 'number' ? `0x${chainId.toString(16)}` : chainId\n    networks[id] = getContractForNetwork(net)\n  } else if (net.provider || net.web3 || net.rpcUrl) {\n    networks[net.name || ''] = getContractForNetwork(net)\n  }\n  return networks\n}\n\nfunction configureNetworks(conf: MultiProviderConfiguration): ConfiguredNetworks {\n  return {\n    ...configureNetwork(conf),\n    ...conf.networks?.reduce<ConfiguredNetworks>((networks, net) => {\n      return { ...networks, ...configureNetwork(net) }\n    }, {}),\n  }\n}\n\n/**\n * Generates a configuration that maps ethereum network names and chainIDs to the respective ERC1056 contracts deployed on them.\n * @returns a record of ERC1056 `Contract` instances\n * @param conf configuration options for the resolver. An array of network details.\n * Each network entry should contain at least one of `name` or `chainId` AND one of `provider`, `web3`, or `rpcUrl`\n * For convenience, you can also specify an `infuraProjectId` which will create a mapping for all the networks supported by https://infura.io.\n * @example ```js\n * [\n *   { name: 'development', registry: '0x9af37603e98e0dc2b855be647c39abe984fc2445', rpcUrl: 'http://127.0.0.1:8545/' },\n *   { name: 'goerli', chainId: 5, provider: new InfuraProvider('goerli') },\n *   { name: 'rinkeby', provider: new AlchemyProvider('rinkeby') },\n *   { name: 'rsk:testnet', chainId: '0x1f', rpcUrl: 'https://public-node.testnet.rsk.co' },\n * ]\n * ```\n */\nexport function configureResolverWithNetworks(conf: ConfigurationOptions = {}): ConfiguredNetworks {\n  const networks = {\n    ...configureNetworksWithInfura((<InfuraConfiguration>conf).infuraProjectId),\n    ...configureNetworks(<MultiProviderConfiguration>conf),\n  }\n  if (Object.keys(networks).length === 0) {\n    throw new Error('invalid_config: Please make sure to have at least one network')\n  }\n  return networks\n}\n","import { Signer } from '@ethersproject/abstract-signer'\nimport { CallOverrides, Contract } from '@ethersproject/contracts'\nimport { BlockTag, JsonRpcProvider, TransactionReceipt } from '@ethersproject/providers'\nimport { address, interpretIdentifier, stringToBytes32 } from './helpers'\n\nexport class EthrDidController {\n  private contract: Contract\n  private signer?: Signer\n  private address: string\n\n  constructor(identifier: string | address, contract: Contract, signer?: Signer) {\n    this.contract = contract\n    this.signer = signer\n    const { address } = interpretIdentifier(identifier)\n    this.address = address\n  }\n\n  async getOwner(address: address, blockTag?: BlockTag): Promise<string> {\n    const result = await this.contract.functions.identityOwner(address, { blockTag })\n    return result[0]\n  }\n\n  async attachContract(controller?: address | Promise<address>): Promise<Contract> {\n    const currentOwner = controller ? await controller : await this.getOwner(this.address, 'latest')\n    const signer = this.signer\n      ? this.signer\n      : (<JsonRpcProvider>this.contract.provider).getSigner(currentOwner) || this.contract.signer\n    return this.contract.connect(signer)\n  }\n\n  async changeOwner(newOwner: address, options: CallOverrides = {}): Promise<TransactionReceipt> {\n    // console.log(`changing owner for ${oldOwner} on registry at ${registryContract.address}`)\n    const overrides = {\n      gasLimit: 123456,\n      gasPrice: 1000000000,\n      ...options,\n    }\n\n    const contract = await this.attachContract(overrides.from)\n    delete overrides.from\n\n    const ownerChange = await contract.functions.changeOwner(this.address, newOwner, overrides)\n    return await ownerChange.wait()\n  }\n\n  async addDelegate(\n    delegateType: string,\n    delegateAddress: address,\n    exp: number,\n    options: CallOverrides = {}\n  ): Promise<TransactionReceipt> {\n    const overrides = {\n      gasLimit: 123456,\n      gasPrice: 1000000000,\n      ...options,\n    }\n    const contract = await this.attachContract(overrides.from)\n    delete overrides.from\n\n    const delegateTypeBytes = stringToBytes32(delegateType)\n    const addDelegateTx = await contract.functions.addDelegate(\n      this.address,\n      delegateTypeBytes,\n      delegateAddress,\n      exp,\n      overrides\n    )\n    addDelegateTx\n    return await addDelegateTx.wait()\n  }\n\n  async revokeDelegate(\n    delegateType: string,\n    delegateAddress: address,\n    options: CallOverrides = {}\n  ): Promise<TransactionReceipt> {\n    const overrides = {\n      gasLimit: 123456,\n      gasPrice: 1000000000,\n      ...options,\n    }\n    delegateType = delegateType.startsWith('0x') ? delegateType : stringToBytes32(delegateType)\n    const contract = await this.attachContract(overrides.from)\n    delete overrides.from\n    const addDelegateTx = await contract.functions.revokeDelegate(\n      this.address,\n      delegateType,\n      delegateAddress,\n      overrides\n    )\n    return await addDelegateTx.wait()\n  }\n\n  async setAttribute(\n    attrName: string,\n    attrValue: string,\n    exp: number,\n    options: CallOverrides = {}\n  ): Promise<TransactionReceipt> {\n    const overrides = {\n      gasLimit: 123456,\n      gasPrice: 1000000000,\n      controller: undefined,\n      ...options,\n    }\n    attrName = attrName.startsWith('0x') ? attrName : stringToBytes32(attrName)\n    attrValue = attrValue.startsWith('0x') ? attrValue : '0x' + Buffer.from(attrValue, 'utf-8').toString('hex')\n    const contract = await this.attachContract(overrides.from)\n    delete overrides.from\n    const setAttrTx = await contract.functions.setAttribute(this.address, attrName, attrValue, exp, overrides)\n    return await setAttrTx.wait()\n  }\n\n  async revokeAttribute(attrName: string, attrValue: string, options: CallOverrides = {}): Promise<TransactionReceipt> {\n    // console.log(`revoking attribute ${attrName}(${attrValue}) for ${identity}`)\n    const overrides = {\n      gasLimit: 123456,\n      gasPrice: 1000000000,\n      ...options,\n    }\n    attrName = attrName.startsWith('0x') ? attrName : stringToBytes32(attrName)\n    attrValue = attrValue.startsWith('0x') ? attrValue : '0x' + Buffer.from(attrValue, 'utf-8').toString('hex')\n    const contract = await this.attachContract(overrides.from)\n    delete overrides.from\n    const revokeAttributeTX = await contract.functions.revokeAttribute(this.address, attrName, attrValue, overrides)\n    return await revokeAttributeTX.wait()\n  }\n}\n","import { Base58 } from '@ethersproject/basex'\nimport { BigNumber } from '@ethersproject/bignumber'\nimport { BlockTag } from '@ethersproject/providers'\nimport { ConfigurationOptions, ConfiguredNetworks, configureResolverWithNetworks } from './configuration'\nimport { EthrDidController } from './controller'\nimport {\n  DIDDocument,\n  DIDResolutionOptions,\n  DIDResolutionResult,\n  DIDResolver,\n  ParsedDID,\n  Resolver,\n  ServiceEndpoint,\n  VerificationMethod,\n} from 'did-resolver'\nimport {\n  interpretIdentifier,\n  DIDAttributeChanged,\n  DIDDelegateChanged,\n  ERC1056Event,\n  eventNames,\n  legacyAlgoMap,\n  legacyAttrTypes,\n  LegacyVerificationMethod,\n  verificationMethodTypes,\n  identifierMatcher,\n  nullAddress,\n  DIDOwnerChanged,\n  knownNetworks,\n} from './helpers'\nimport { logDecoder } from './logParser'\n\nexport function getResolver(options: ConfigurationOptions): Record<string, DIDResolver> {\n  return new EthrDidResolver(options).build()\n}\n\nexport class EthrDidResolver {\n  private contracts: ConfiguredNetworks\n\n  constructor(options: ConfigurationOptions) {\n    this.contracts = configureResolverWithNetworks(options)\n  }\n\n  /**\n   * returns the current owner of a DID (represented by an address or public key)\n   *\n   * @param address\n   */\n  async getOwner(address: string, networkId: string, blockTag?: BlockTag): Promise<string> {\n    //TODO: check if address or public key\n    return new EthrDidController(address, this.contracts[networkId]).getOwner(address, blockTag)\n  }\n\n  /**\n   * returns the previous change\n   *\n   * @param address\n   */\n  async previousChange(address: string, networkId: string, blockTag?: BlockTag): Promise<BigNumber> {\n    const result = await this.contracts[networkId].functions.changed(address, { blockTag })\n    // console.log(`last change result: '${BigNumber.from(result['0'])}'`)\n    return BigNumber.from(result['0'])\n  }\n\n  async changeLog(\n    identity: string,\n    networkId: string,\n    blockTag: BlockTag = 'latest'\n  ): Promise<{ controller: string; history: ERC1056Event[]; controllerKey?: string; chainId: number }> {\n    const contract = this.contracts[networkId]\n    const provider = contract.provider\n    const hexChainId = networkId.startsWith('0x') ? networkId : knownNetworks[networkId]\n    //TODO: this can be used to check if the configuration is ok\n    const chainIdFromNetwork = (await provider.getNetwork()).chainId\n    const chainId = hexChainId ? BigNumber.from(hexChainId).toNumber() : chainIdFromNetwork\n    const history: ERC1056Event[] = []\n    const { address, publicKey } = interpretIdentifier(identity)\n    let controllerKey = publicKey\n    let controller = address\n    let previousChange: BigNumber | null = await this.previousChange(address, networkId, blockTag)\n    // console.log(`gigel 1 - '${previousChange}' - ${typeof previousChange}`)\n    if (previousChange) {\n      const newController = await this.getOwner(address, networkId, blockTag)\n      if (newController.toLowerCase() !== controller.toLowerCase()) {\n        controllerKey = undefined\n      }\n      controller = newController\n    }\n    while (previousChange) {\n      const blockNumber = previousChange\n      // console.log(`gigel ${previousChange}`)\n      const logs = await provider.getLogs({\n        address: contract.address, // networks[networkId].registryAddress,\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        topics: [null as any, `0x000000000000000000000000${address.slice(2)}`],\n        fromBlock: previousChange.toHexString(),\n        toBlock: previousChange.toHexString(),\n      })\n      const events: ERC1056Event[] = logDecoder(contract, logs)\n      events.reverse()\n      previousChange = null\n      for (const event of events) {\n        history.unshift(event)\n        if (event.previousChange.lt(blockNumber)) {\n          previousChange = event.previousChange\n        }\n      }\n    }\n    return { controller, history, controllerKey, chainId }\n  }\n\n  wrapDidDocument(\n    did: string,\n    controller: string,\n    controllerKey: string | undefined,\n    history: ERC1056Event[],\n    chainId: number\n  ): { didDocument: DIDDocument; deactivated: boolean } {\n    const baseDIDDocument: DIDDocument = {\n      '@context': [\n        'https://www.w3.org/ns/did/v1',\n        'https://identity.foundation/EcdsaSecp256k1RecoverySignature2020/lds-ecdsa-secp256k1-recovery2020-0.0.jsonld',\n      ],\n      id: did,\n      verificationMethod: [],\n      authentication: [],\n    }\n\n    // const now = new BN(Math.floor(new Date().getTime() / 1000))\n    const now = BigNumber.from(Math.floor(new Date().getTime() / 1000))\n    // const expired = {}\n    const publicKeys: VerificationMethod[] = [\n      {\n        id: `${did}#controller`,\n        type: verificationMethodTypes.EcdsaSecp256k1RecoveryMethod2020,\n        controller: did,\n        blockchainAccountId: `${controller}@eip155:${chainId}`,\n      },\n    ]\n\n    const authentication = [`${did}#controller`]\n\n    if (controllerKey) {\n      publicKeys.push({\n        id: `${did}#controllerKey`,\n        type: verificationMethodTypes.EcdsaSecp256k1VerificationKey2019,\n        controller: did,\n        publicKeyHex: controllerKey,\n      })\n      authentication.push(`${did}#controllerKey`)\n    }\n\n    let deactivated = false\n    let delegateCount = 0\n    let serviceCount = 0\n    const auth: Record<string, string> = {}\n    const pks: Record<string, VerificationMethod> = {}\n    const services: Record<string, ServiceEndpoint> = {}\n    for (const event of history) {\n      const validTo = event.validTo || BigNumber.from(0)\n      const eventIndex = `${event._eventName}-${\n        (<DIDDelegateChanged>event).delegateType || (<DIDAttributeChanged>event).name\n      }-${(<DIDDelegateChanged>event).delegate || (<DIDAttributeChanged>event).value}`\n      if (validTo && validTo.gte(now)) {\n        if (event._eventName === eventNames.DIDDelegateChanged) {\n          const currentEvent = <DIDDelegateChanged>event\n          delegateCount++\n          const delegateType = currentEvent.delegateType //conversion from bytes32 is done in logParser\n          switch (delegateType) {\n            case 'sigAuth':\n              auth[eventIndex] = `${did}#delegate-${delegateCount}`\n            // eslint-disable-line no-fallthrough\n            case 'veriKey':\n              pks[eventIndex] = {\n                id: `${did}#delegate-${delegateCount}`,\n                type: verificationMethodTypes.EcdsaSecp256k1RecoveryMethod2020,\n                controller: did,\n                blockchainAccountId: `${currentEvent.delegate}@eip155:${chainId}`,\n              }\n              break\n          }\n        } else if (event._eventName === eventNames.DIDAttributeChanged) {\n          const currentEvent = <DIDAttributeChanged>event\n          const name = currentEvent.name //conversion from bytes32 is done in logParser\n          const match = name.match(/^did\\/(pub|svc)\\/(\\w+)(\\/(\\w+))?(\\/(\\w+))?$/)\n          if (match) {\n            const section = match[1]\n            const algorithm = match[2]\n            const type = legacyAttrTypes[match[4]] || match[4]\n            const encoding = match[6]\n            switch (section) {\n              case 'pub': {\n                delegateCount++\n                const pk: LegacyVerificationMethod = {\n                  id: `${did}#delegate-${delegateCount}`,\n                  type: `${algorithm}${type}`,\n                  controller: did,\n                }\n                pk.type = legacyAlgoMap[pk.type] || algorithm\n                switch (encoding) {\n                  case null:\n                  case undefined:\n                  case 'hex':\n                    pk.publicKeyHex = currentEvent.value.slice(2)\n                    break\n                  case 'base64':\n                    pk.publicKeyBase64 = Buffer.from(currentEvent.value.slice(2), 'hex').toString('base64')\n                    break\n                  case 'base58':\n                    pk.publicKeyBase58 = Base58.encode(Buffer.from(currentEvent.value.slice(2), 'hex'))\n                    break\n                  case 'pem':\n                    pk.publicKeyPem = Buffer.from(currentEvent.value.slice(2), 'hex').toString()\n                    break\n                  default:\n                    pk.value = currentEvent.value\n                }\n                pks[eventIndex] = pk\n                if (match[4] === 'sigAuth') {\n                  auth[eventIndex] = pk.id\n                }\n                break\n              }\n              case 'svc':\n                serviceCount++\n                services[eventIndex] = {\n                  id: `${did}#service-${serviceCount}`,\n                  type: algorithm,\n                  serviceEndpoint: Buffer.from(currentEvent.value.slice(2), 'hex').toString(),\n                }\n                break\n            }\n          }\n        }\n      } else {\n        if (\n          event._eventName === eventNames.DIDDelegateChanged ||\n          (event._eventName === eventNames.DIDAttributeChanged &&\n            (<DIDAttributeChanged>event).name.match(/^did\\/pub\\//))\n        ) {\n          delegateCount++\n        } else if (\n          event._eventName === eventNames.DIDAttributeChanged &&\n          (<DIDAttributeChanged>event).name.match(/^did\\/svc\\//)\n        ) {\n          serviceCount++\n        }\n        delete auth[eventIndex]\n        delete pks[eventIndex]\n        delete services[eventIndex]\n\n        if (event._eventName === eventNames.DIDOwnerChanged) {\n          if ((<DIDOwnerChanged>event).owner === nullAddress) {\n            deactivated = true\n            break\n          }\n        }\n      }\n    }\n\n    const doc: DIDDocument = {\n      ...baseDIDDocument,\n      verificationMethod: publicKeys.concat(Object.values(pks)),\n      authentication: authentication.concat(Object.values(auth)),\n    }\n    if (Object.values(services).length > 0) {\n      doc.service = Object.values(services)\n    }\n\n    return deactivated\n      ? { didDocument: { ...baseDIDDocument, '@context': 'https://www.w3.org/ns/did/v1' }, deactivated }\n      : { didDocument: doc, deactivated }\n  }\n\n  async resolve(\n    did: string,\n    parsed: ParsedDID,\n    _unused: Resolver,\n    options: DIDResolutionOptions\n  ): Promise<DIDResolutionResult> {\n    const fullId = parsed.id.match(identifierMatcher)\n    if (!fullId) {\n      throw new Error(`Not a valid ethr DID: ${did}`)\n    }\n    const id = fullId[2]\n    const networkId = !fullId[1] ? 'mainnet' : fullId[1].slice(0, -1)\n\n    if (!this.contracts[networkId])\n      throw new Error(`unknown_network: The DID resolver does not have a configuration for network: ${networkId}`)\n\n    const { controller, history, controllerKey, chainId } = await this.changeLog(id, networkId, options.blockTag)\n    try {\n      const { didDocument, deactivated } = this.wrapDidDocument(did, controller, controllerKey, history, chainId)\n      const status = deactivated ? { deactivated: true } : {}\n      return {\n        didDocumentMetadata: { ...status },\n        didResolutionMetadata: { contentType: 'application/did+ld+json' },\n        didDocument,\n      }\n    } catch (e) {\n      return {\n        didResolutionMetadata: {\n          error: 'notFound',\n          message: e.toString(), // This is not in spec, nut may be helpful\n        },\n        didDocumentMetadata: {},\n        didDocument: null,\n      }\n    }\n  }\n\n  build(): Record<string, DIDResolver> {\n    return { ethr: this.resolve.bind(this) }\n  }\n}\n","import { BigNumber } from '@ethersproject/bignumber'\nimport { Contract } from '@ethersproject/contracts'\nimport { Log } from '@ethersproject/providers'\nimport { LogDescription } from '@ethersproject/abi'\nimport { bytes32toString, ERC1056Event } from './helpers'\n\nfunction populateEventMetaClass(logResult: LogDescription): ERC1056Event {\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  const result: Record<string, any> = {}\n  if (logResult.eventFragment.inputs.length !== logResult.args.length) {\n    throw new TypeError('malformed event input. wrong number of arguments')\n  }\n  logResult.eventFragment.inputs.forEach((input, index) => {\n    let val = logResult.args[index]\n    if (typeof val === 'object') {\n      val = BigNumber.from(val)\n    }\n    if (input.type === 'bytes32') {\n      val = bytes32toString(val)\n    }\n    result[input.name] = val\n  })\n  result._eventName = logResult.name\n  return result as ERC1056Event\n}\n\nexport function logDecoder(contract: Contract, logs: Log[]): ERC1056Event[] {\n  const results: ERC1056Event[] = logs.map((log: Log) => {\n    const res = contract.interface.parseLog(log)\n    const event = populateEventMetaClass(res)\n    return event\n  })\n  return results\n}\n"],"names":["identifierMatcher","verificationMethodTypes","eventNames","legacyAttrTypes","sigAuth","veriKey","enc","legacyAlgoMap","Secp256k1VerificationKey2018","EcdsaSecp256k1VerificationKey2019","Ed25519SignatureAuthentication2018","Ed25519VerificationKey2018","Secp256k1SignatureAuthentication2018","RSAVerificationKey2018","X25519KeyAgreementKey2019","bytes32toString","input","Buffer","from","slice","toString","replace","stringToBytes32","str","buffStr","repeat","length","interpretIdentifier","identifier","address","computeAddress","publicKey","getAddress","knownNetworks","mainnet","ropsten","rinkeby","goerli","kovan","getContractForNetwork","conf","provider","web3","_conf$web","currentProvider","rpcUrl","Error","name","chainId","BigNumber","toNumber","networkName","_conf$name","JsonRpcProvider","ContractFactory","fromSolidity","DidRegistryContract","attach","registry","connect","configureNetwork","net","networks","configureNetworks","_conf$networks","reduce","EthrDidController","constructor","contract","signer","this","getOwner","blockTag","functions","identityOwner","result","attachContract","controller","_this2","currentOwner","getSigner","changeOwner","newOwner","options","overrides","gasLimit","gasPrice","_this3","ownerChange","wait","addDelegate","delegateType","delegateAddress","exp","_this4","delegateTypeBytes","addDelegateTx","revokeDelegate","startsWith","_this5","setAttribute","attrName","attrValue","undefined","_this6","setAttrTx","revokeAttribute","_this7","revokeAttributeTX","pact","state","value","v","_settle","o","prototype","s","e","thenable","EthrDidResolver","contracts","projectId","infuraProjectId","InfuraProvider","Object","keys","configureResolverWithNetworks","networkId","previousChange","changed","changeLog","identity","hexChainId","getNetwork","chainIdFromNetwork","_provider$getNetwork","history","controllerKey","blockNumber","getLogs","topics","fromBlock","toHexString","toBlock","logs","events","map","log","logResult","eventFragment","inputs","args","TypeError","forEach","index","val","type","_eventName","populateEventMetaClass","interface","parseLog","logDecoder","reverse","event","unshift","lt","newController","toLowerCase","wrapDidDocument","did","baseDIDDocument","@context","id","verificationMethod","authentication","now","Math","floor","Date","getTime","publicKeys","EcdsaSecp256k1RecoveryMethod2020","blockchainAccountId","push","publicKeyHex","deactivated","delegateCount","serviceCount","auth","pks","services","validTo","eventIndex","delegate","gte","DIDDelegateChanged","currentEvent","DIDAttributeChanged","match","algorithm","encoding","pk","publicKeyBase64","publicKeyBase58","Base58","encode","publicKeyPem","serviceEndpoint","DIDOwnerChanged","owner","doc","concat","values","service","didDocument","resolve","parsed","_unused","fullId","didDocumentMetadata","didResolutionMetadata","contentType","error","message","build","ethr","bind"],"mappings":"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"}