{"version":3,"file":"index.modern.js","sources":["../src/helpers.ts","../src/configuration.ts","../src/controller.ts","../src/logParser.ts","../src/resolver.ts"],"sourcesContent":["import { getAddress } from '@ethersproject/address'\nimport { BigNumber } from '@ethersproject/bignumber'\nimport { computeAddress } from '@ethersproject/transactions'\nimport { VerificationMethod } from 'did-resolver'\n\nexport const identifierMatcher = /^(.*)?(0x[0-9a-fA-F]{40}|0x[0-9a-fA-F]{66})$/\nexport const nullAddress = '0x0000000000000000000000000000000000000000'\nexport const DEFAULT_REGISTRY_ADDRESS = '0xdca7ef03e98e0dc2b855be647c39abe984fcf21b'\nexport const DEFAULT_JSON_RPC = 'http://127.0.0.1:8545/'\n\nexport type address = string\nexport type uint256 = BigNumber\nexport type bytes32 = string\nexport type bytes = string\n\nexport interface ERC1056Event {\n  identity: address\n  previousChange: uint256\n  validTo?: uint256\n  _eventName: string\n}\n\nexport interface DIDOwnerChanged extends ERC1056Event {\n  owner: address\n}\n\nexport interface DIDAttributeChanged extends ERC1056Event {\n  name: bytes32\n  value: bytes\n  validTo: uint256\n}\n\nexport interface DIDDelegateChanged extends ERC1056Event {\n  delegateType: bytes32\n  delegate: address\n  validTo: uint256\n}\n\nexport enum verificationMethodTypes {\n  EcdsaSecp256k1VerificationKey2019 = 'EcdsaSecp256k1VerificationKey2019',\n  EcdsaSecp256k1RecoveryMethod2020 = 'EcdsaSecp256k1RecoveryMethod2020',\n  Ed25519VerificationKey2018 = 'Ed25519VerificationKey2018',\n  RSAVerificationKey2018 = 'RSAVerificationKey2018',\n  X25519KeyAgreementKey2019 = 'X25519KeyAgreementKey2019',\n}\n\nexport enum eventNames {\n  DIDOwnerChanged = 'DIDOwnerChanged',\n  DIDAttributeChanged = 'DIDAttributeChanged',\n  DIDDelegateChanged = 'DIDDelegateChanged',\n}\n\nexport interface LegacyVerificationMethod extends VerificationMethod {\n  /**@deprecated */\n  publicKeyHex?: string\n  /**@deprecated */\n  publicKeyBase64?: string\n  /**@deprecated */\n  publicKeyPem?: string\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  [x: string]: any\n}\n\nexport const legacyAttrTypes: Record<string, string> = {\n  sigAuth: 'SignatureAuthentication2018',\n  veriKey: 'VerificationKey2018',\n  enc: 'KeyAgreementKey2019',\n}\n\nexport const legacyAlgoMap: Record<string, string> = {\n  /**@deprecated */\n  Secp256k1VerificationKey2018: verificationMethodTypes.EcdsaSecp256k1VerificationKey2019,\n  /**@deprecated */\n  Ed25519SignatureAuthentication2018: verificationMethodTypes.Ed25519VerificationKey2018,\n  /**@deprecated */\n  Secp256k1SignatureAuthentication2018: verificationMethodTypes.EcdsaSecp256k1VerificationKey2019,\n  //keep legacy mapping\n  RSAVerificationKey2018: verificationMethodTypes.RSAVerificationKey2018,\n  Ed25519VerificationKey2018: verificationMethodTypes.Ed25519VerificationKey2018,\n  X25519KeyAgreementKey2019: verificationMethodTypes.X25519KeyAgreementKey2019,\n}\n\nexport function bytes32toString(input: bytes32 | Uint8Array): string {\n  const buff: Buffer = typeof input === 'string' ? Buffer.from(input.slice(2), 'hex') : Buffer.from(input)\n  return buff.toString('utf8').replace(/\\0+$/, '')\n}\n\nexport function stringToBytes32(str: string): string {\n  const buffStr = '0x' + Buffer.from(str).slice(0, 32).toString('hex')\n  return buffStr + '0'.repeat(66 - buffStr.length)\n}\n\nexport function interpretIdentifier(identifier: string): { address: string; publicKey?: string } {\n  if (identifier.length > 42) {\n    return { address: computeAddress(identifier), publicKey: identifier }\n  } else {\n    return { address: getAddress(identifier) } // checksum address\n  }\n}\n\nconst knownInfuraNetworks: Record<string, string> = {\n  mainnet: '0x1',\n  ropsten: '0x3',\n  rinkeby: '0x4',\n  goerli: '0x5',\n  kovan: '0x2a',\n}\n\nexport const knownNetworks: Record<string, string> = {\n  ...knownInfuraNetworks,\n}\n","import { BigNumber } from '@ethersproject/bignumber'\nimport { Contract, ContractFactory } from '@ethersproject/contracts'\nimport { InfuraProvider, JsonRpcProvider, Provider } from '@ethersproject/providers'\nimport DidRegistryContract from 'ethr-did-registry'\nimport { DEFAULT_REGISTRY_ADDRESS, knownNetworks } from './helpers'\n\n/**\n * A configuration entry for an ethereum network\n * It should contain at least one of `name` or `chainId` AND one of `provider`, `web3`, or `rpcUrl`\n *\n * @example ```js\n * { name: 'development', registry: '0x9af37603e98e0dc2b855be647c39abe984fc2445', rpcUrl: 'http://127.0.0.1:8545/' }\n * { name: 'goerli', chainId: 5, provider: new InfuraProvider('goerli') }\n * { name: 'rinkeby', provider: new AlchemyProvider('rinkeby') }\n * { name: 'rsk:testnet', chainId: '0x1f', rpcUrl: 'https://public-node.testnet.rsk.co' }\n * ```\n */\nexport interface ProviderConfiguration {\n  name?: string\n  provider?: Provider\n  rpcUrl?: string\n  registry?: string\n  chainId?: string | number\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  web3?: any\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  [index: string]: any\n}\n\nexport interface MultiProviderConfiguration extends ProviderConfiguration {\n  networks?: ProviderConfiguration[]\n}\n\nexport interface InfuraConfiguration {\n  infuraProjectId: string\n}\n\nexport type ConfigurationOptions = MultiProviderConfiguration | InfuraConfiguration\n\nexport type ConfiguredNetworks = Record<string, Contract>\n\nfunction configureNetworksWithInfura(projectId?: string): ConfiguredNetworks {\n  if (!projectId) {\n    return {}\n  }\n  const networks: ProviderConfiguration[] = [\n    { name: 'mainnet', chainId: '0x1', provider: new InfuraProvider('homestead', projectId) },\n    { name: 'ropsten', chainId: '0x3', provider: new InfuraProvider('ropsten', projectId) },\n    { name: 'rinkeby', chainId: '0x4', provider: new InfuraProvider('rinkeby', projectId) },\n    { name: 'goerli', chainId: '0x5', provider: new InfuraProvider('goerli', projectId) },\n    { name: 'kovan', chainId: '0x2a', provider: new InfuraProvider('kovan', projectId) },\n  ]\n  return configureNetworks({ networks })\n}\n\nfunction getContractForNetwork(conf: ProviderConfiguration): Contract {\n  let provider: Provider = conf.provider || conf.web3?.currentProvider\n  if (!provider) {\n    if (conf.rpcUrl) {\n      const chainId = conf.chainId ? BigNumber.from(conf.chainId).toNumber() : conf.chainId\n      const networkName = knownNetworks[conf.name || ''] ? conf.name?.replace('mainnet', 'homestead') : 'any'\n      provider = new JsonRpcProvider(conf.rpcUrl, chainId || networkName)\n    } else {\n      throw new Error(`invalid_config: No web3 provider could be determined for network ${conf.name || conf.chainId}`)\n    }\n  }\n  const contract: Contract = ContractFactory.fromSolidity(DidRegistryContract)\n    .attach(conf.registry || DEFAULT_REGISTRY_ADDRESS)\n    .connect(provider)\n  return contract\n}\n\nfunction configureNetwork(net: ProviderConfiguration): ConfiguredNetworks {\n  const networks: ConfiguredNetworks = {}\n  const chainId = net.chainId || knownNetworks[net.name || '']\n  if (chainId) {\n    if (net.name) {\n      networks[net.name] = getContractForNetwork(net)\n    }\n    const id = typeof chainId === 'number' ? `0x${chainId.toString(16)}` : chainId\n    networks[id] = getContractForNetwork(net)\n  } else if (net.provider || net.web3 || net.rpcUrl) {\n    networks[net.name || ''] = getContractForNetwork(net)\n  }\n  return networks\n}\n\nfunction configureNetworks(conf: MultiProviderConfiguration): ConfiguredNetworks {\n  return {\n    ...configureNetwork(conf),\n    ...conf.networks?.reduce<ConfiguredNetworks>((networks, net) => {\n      return { ...networks, ...configureNetwork(net) }\n    }, {}),\n  }\n}\n\n/**\n * Generates a configuration that maps ethereum network names and chainIDs to the respective ERC1056 contracts deployed on them.\n * @returns a record of ERC1056 `Contract` instances\n * @param conf configuration options for the resolver. An array of network details.\n * Each network entry should contain at least one of `name` or `chainId` AND one of `provider`, `web3`, or `rpcUrl`\n * For convenience, you can also specify an `infuraProjectId` which will create a mapping for all the networks supported by https://infura.io.\n * @example ```js\n * [\n *   { name: 'development', registry: '0x9af37603e98e0dc2b855be647c39abe984fc2445', rpcUrl: 'http://127.0.0.1:8545/' },\n *   { name: 'goerli', chainId: 5, provider: new InfuraProvider('goerli') },\n *   { name: 'rinkeby', provider: new AlchemyProvider('rinkeby') },\n *   { name: 'rsk:testnet', chainId: '0x1f', rpcUrl: 'https://public-node.testnet.rsk.co' },\n * ]\n * ```\n */\nexport function configureResolverWithNetworks(conf: ConfigurationOptions = {}): ConfiguredNetworks {\n  const networks = {\n    ...configureNetworksWithInfura((<InfuraConfiguration>conf).infuraProjectId),\n    ...configureNetworks(<MultiProviderConfiguration>conf),\n  }\n  if (Object.keys(networks).length === 0) {\n    throw new Error('invalid_config: Please make sure to have at least one network')\n  }\n  return networks\n}\n","import { Signer } from '@ethersproject/abstract-signer'\nimport { CallOverrides, Contract } from '@ethersproject/contracts'\nimport { BlockTag, JsonRpcProvider, TransactionReceipt } from '@ethersproject/providers'\nimport { address, interpretIdentifier, stringToBytes32 } from './helpers'\n\nexport class EthrDidController {\n  private contract: Contract\n  private signer?: Signer\n  private address: string\n\n  constructor(identifier: string | address, contract: Contract, signer?: Signer) {\n    this.contract = contract\n    this.signer = signer\n    const { address } = interpretIdentifier(identifier)\n    this.address = address\n  }\n\n  async getOwner(address: address, blockTag?: BlockTag): Promise<string> {\n    const result = await this.contract.functions.identityOwner(address, { blockTag })\n    return result[0]\n  }\n\n  async attachContract(controller?: address | Promise<address>): Promise<Contract> {\n    const currentOwner = controller ? await controller : await this.getOwner(this.address, 'latest')\n    const signer = this.signer\n      ? this.signer\n      : (<JsonRpcProvider>this.contract.provider).getSigner(currentOwner) || this.contract.signer\n    return this.contract.connect(signer)\n  }\n\n  async changeOwner(newOwner: address, options: CallOverrides = {}): Promise<TransactionReceipt> {\n    // console.log(`changing owner for ${oldOwner} on registry at ${registryContract.address}`)\n    const overrides = {\n      gasLimit: 123456,\n      gasPrice: 1000000000,\n      ...options,\n    }\n\n    const contract = await this.attachContract(overrides.from)\n    delete overrides.from\n\n    const ownerChange = await contract.functions.changeOwner(this.address, newOwner, overrides)\n    return await ownerChange.wait()\n  }\n\n  async addDelegate(\n    delegateType: string,\n    delegateAddress: address,\n    exp: number,\n    options: CallOverrides = {}\n  ): Promise<TransactionReceipt> {\n    const overrides = {\n      gasLimit: 123456,\n      gasPrice: 1000000000,\n      ...options,\n    }\n    const contract = await this.attachContract(overrides.from)\n    delete overrides.from\n\n    const delegateTypeBytes = stringToBytes32(delegateType)\n    const addDelegateTx = await contract.functions.addDelegate(\n      this.address,\n      delegateTypeBytes,\n      delegateAddress,\n      exp,\n      overrides\n    )\n    addDelegateTx\n    return await addDelegateTx.wait()\n  }\n\n  async revokeDelegate(\n    delegateType: string,\n    delegateAddress: address,\n    options: CallOverrides = {}\n  ): Promise<TransactionReceipt> {\n    const overrides = {\n      gasLimit: 123456,\n      gasPrice: 1000000000,\n      ...options,\n    }\n    delegateType = delegateType.startsWith('0x') ? delegateType : stringToBytes32(delegateType)\n    const contract = await this.attachContract(overrides.from)\n    delete overrides.from\n    const addDelegateTx = await contract.functions.revokeDelegate(\n      this.address,\n      delegateType,\n      delegateAddress,\n      overrides\n    )\n    return await addDelegateTx.wait()\n  }\n\n  async setAttribute(\n    attrName: string,\n    attrValue: string,\n    exp: number,\n    options: CallOverrides = {}\n  ): Promise<TransactionReceipt> {\n    const overrides = {\n      gasLimit: 123456,\n      gasPrice: 1000000000,\n      controller: undefined,\n      ...options,\n    }\n    attrName = attrName.startsWith('0x') ? attrName : stringToBytes32(attrName)\n    attrValue = attrValue.startsWith('0x') ? attrValue : '0x' + Buffer.from(attrValue, 'utf-8').toString('hex')\n    const contract = await this.attachContract(overrides.from)\n    delete overrides.from\n    const setAttrTx = await contract.functions.setAttribute(this.address, attrName, attrValue, exp, overrides)\n    return await setAttrTx.wait()\n  }\n\n  async revokeAttribute(attrName: string, attrValue: string, options: CallOverrides = {}): Promise<TransactionReceipt> {\n    // console.log(`revoking attribute ${attrName}(${attrValue}) for ${identity}`)\n    const overrides = {\n      gasLimit: 123456,\n      gasPrice: 1000000000,\n      ...options,\n    }\n    attrName = attrName.startsWith('0x') ? attrName : stringToBytes32(attrName)\n    attrValue = attrValue.startsWith('0x') ? attrValue : '0x' + Buffer.from(attrValue, 'utf-8').toString('hex')\n    const contract = await this.attachContract(overrides.from)\n    delete overrides.from\n    const revokeAttributeTX = await contract.functions.revokeAttribute(this.address, attrName, attrValue, overrides)\n    return await revokeAttributeTX.wait()\n  }\n}\n","import { BigNumber } from '@ethersproject/bignumber'\nimport { Contract } from '@ethersproject/contracts'\nimport { Log } from '@ethersproject/providers'\nimport { LogDescription } from '@ethersproject/abi'\nimport { bytes32toString, ERC1056Event } from './helpers'\n\nfunction populateEventMetaClass(logResult: LogDescription): ERC1056Event {\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  const result: Record<string, any> = {}\n  if (logResult.eventFragment.inputs.length !== logResult.args.length) {\n    throw new TypeError('malformed event input. wrong number of arguments')\n  }\n  logResult.eventFragment.inputs.forEach((input, index) => {\n    let val = logResult.args[index]\n    if (typeof val === 'object') {\n      val = BigNumber.from(val)\n    }\n    if (input.type === 'bytes32') {\n      val = bytes32toString(val)\n    }\n    result[input.name] = val\n  })\n  result._eventName = logResult.name\n  return result as ERC1056Event\n}\n\nexport function logDecoder(contract: Contract, logs: Log[]): ERC1056Event[] {\n  const results: ERC1056Event[] = logs.map((log: Log) => {\n    const res = contract.interface.parseLog(log)\n    const event = populateEventMetaClass(res)\n    return event\n  })\n  return results\n}\n","import { Base58 } from '@ethersproject/basex'\nimport { BigNumber } from '@ethersproject/bignumber'\nimport { BlockTag } from '@ethersproject/providers'\nimport { ConfigurationOptions, ConfiguredNetworks, configureResolverWithNetworks } from './configuration'\nimport { EthrDidController } from './controller'\nimport {\n  DIDDocument,\n  DIDResolutionOptions,\n  DIDResolutionResult,\n  DIDResolver,\n  ParsedDID,\n  Resolver,\n  ServiceEndpoint,\n  VerificationMethod,\n} from 'did-resolver'\nimport {\n  interpretIdentifier,\n  DIDAttributeChanged,\n  DIDDelegateChanged,\n  ERC1056Event,\n  eventNames,\n  legacyAlgoMap,\n  legacyAttrTypes,\n  LegacyVerificationMethod,\n  verificationMethodTypes,\n  identifierMatcher,\n  nullAddress,\n  DIDOwnerChanged,\n  knownNetworks,\n} from './helpers'\nimport { logDecoder } from './logParser'\n\nexport function getResolver(options: ConfigurationOptions): Record<string, DIDResolver> {\n  return new EthrDidResolver(options).build()\n}\n\nexport class EthrDidResolver {\n  private contracts: ConfiguredNetworks\n\n  constructor(options: ConfigurationOptions) {\n    this.contracts = configureResolverWithNetworks(options)\n  }\n\n  /**\n   * returns the current owner of a DID (represented by an address or public key)\n   *\n   * @param address\n   */\n  async getOwner(address: string, networkId: string, blockTag?: BlockTag): Promise<string> {\n    //TODO: check if address or public key\n    return new EthrDidController(address, this.contracts[networkId]).getOwner(address, blockTag)\n  }\n\n  /**\n   * returns the previous change\n   *\n   * @param address\n   */\n  async previousChange(address: string, networkId: string, blockTag?: BlockTag): Promise<BigNumber> {\n    const result = await this.contracts[networkId].functions.changed(address, { blockTag })\n    // console.log(`last change result: '${BigNumber.from(result['0'])}'`)\n    return BigNumber.from(result['0'])\n  }\n\n  async changeLog(\n    identity: string,\n    networkId: string,\n    blockTag: BlockTag = 'latest'\n  ): Promise<{ controller: string; history: ERC1056Event[]; controllerKey?: string; chainId: number }> {\n    const contract = this.contracts[networkId]\n    const provider = contract.provider\n    const hexChainId = networkId.startsWith('0x') ? networkId : knownNetworks[networkId]\n    //TODO: this can be used to check if the configuration is ok\n    const chainIdFromNetwork = (await provider.getNetwork()).chainId\n    const chainId = hexChainId ? BigNumber.from(hexChainId).toNumber() : chainIdFromNetwork\n    const history: ERC1056Event[] = []\n    const { address, publicKey } = interpretIdentifier(identity)\n    let controllerKey = publicKey\n    let controller = address\n    let previousChange: BigNumber | null = await this.previousChange(address, networkId, blockTag)\n    // console.log(`gigel 1 - '${previousChange}' - ${typeof previousChange}`)\n    if (previousChange) {\n      const newController = await this.getOwner(address, networkId, blockTag)\n      if (newController.toLowerCase() !== controller.toLowerCase()) {\n        controllerKey = undefined\n      }\n      controller = newController\n    }\n    while (previousChange) {\n      const blockNumber = previousChange\n      // console.log(`gigel ${previousChange}`)\n      const logs = await provider.getLogs({\n        address: contract.address, // networks[networkId].registryAddress,\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        topics: [null as any, `0x000000000000000000000000${address.slice(2)}`],\n        fromBlock: previousChange.toHexString(),\n        toBlock: previousChange.toHexString(),\n      })\n      const events: ERC1056Event[] = logDecoder(contract, logs)\n      events.reverse()\n      previousChange = null\n      for (const event of events) {\n        history.unshift(event)\n        if (event.previousChange.lt(blockNumber)) {\n          previousChange = event.previousChange\n        }\n      }\n    }\n    return { controller, history, controllerKey, chainId }\n  }\n\n  wrapDidDocument(\n    did: string,\n    controller: string,\n    controllerKey: string | undefined,\n    history: ERC1056Event[],\n    chainId: number\n  ): { didDocument: DIDDocument; deactivated: boolean } {\n    const baseDIDDocument: DIDDocument = {\n      '@context': [\n        'https://www.w3.org/ns/did/v1',\n        'https://identity.foundation/EcdsaSecp256k1RecoverySignature2020/lds-ecdsa-secp256k1-recovery2020-0.0.jsonld',\n      ],\n      id: did,\n      verificationMethod: [],\n      authentication: [],\n    }\n\n    // const now = new BN(Math.floor(new Date().getTime() / 1000))\n    const now = BigNumber.from(Math.floor(new Date().getTime() / 1000))\n    // const expired = {}\n    const publicKeys: VerificationMethod[] = [\n      {\n        id: `${did}#controller`,\n        type: verificationMethodTypes.EcdsaSecp256k1RecoveryMethod2020,\n        controller: did,\n        blockchainAccountId: `${controller}@eip155:${chainId}`,\n      },\n    ]\n\n    const authentication = [`${did}#controller`]\n\n    if (controllerKey) {\n      publicKeys.push({\n        id: `${did}#controllerKey`,\n        type: verificationMethodTypes.EcdsaSecp256k1VerificationKey2019,\n        controller: did,\n        publicKeyHex: controllerKey,\n      })\n      authentication.push(`${did}#controllerKey`)\n    }\n\n    let deactivated = false\n    let delegateCount = 0\n    let serviceCount = 0\n    const auth: Record<string, string> = {}\n    const pks: Record<string, VerificationMethod> = {}\n    const services: Record<string, ServiceEndpoint> = {}\n    for (const event of history) {\n      const validTo = event.validTo || BigNumber.from(0)\n      const eventIndex = `${event._eventName}-${\n        (<DIDDelegateChanged>event).delegateType || (<DIDAttributeChanged>event).name\n      }-${(<DIDDelegateChanged>event).delegate || (<DIDAttributeChanged>event).value}`\n      if (validTo && validTo.gte(now)) {\n        if (event._eventName === eventNames.DIDDelegateChanged) {\n          const currentEvent = <DIDDelegateChanged>event\n          delegateCount++\n          const delegateType = currentEvent.delegateType //conversion from bytes32 is done in logParser\n          switch (delegateType) {\n            case 'sigAuth':\n              auth[eventIndex] = `${did}#delegate-${delegateCount}`\n            // eslint-disable-line no-fallthrough\n            case 'veriKey':\n              pks[eventIndex] = {\n                id: `${did}#delegate-${delegateCount}`,\n                type: verificationMethodTypes.EcdsaSecp256k1RecoveryMethod2020,\n                controller: did,\n                blockchainAccountId: `${currentEvent.delegate}@eip155:${chainId}`,\n              }\n              break\n          }\n        } else if (event._eventName === eventNames.DIDAttributeChanged) {\n          const currentEvent = <DIDAttributeChanged>event\n          const name = currentEvent.name //conversion from bytes32 is done in logParser\n          const match = name.match(/^did\\/(pub|svc)\\/(\\w+)(\\/(\\w+))?(\\/(\\w+))?$/)\n          if (match) {\n            const section = match[1]\n            const algorithm = match[2]\n            const type = legacyAttrTypes[match[4]] || match[4]\n            const encoding = match[6]\n            switch (section) {\n              case 'pub': {\n                delegateCount++\n                const pk: LegacyVerificationMethod = {\n                  id: `${did}#delegate-${delegateCount}`,\n                  type: `${algorithm}${type}`,\n                  controller: did,\n                }\n                pk.type = legacyAlgoMap[pk.type] || algorithm\n                switch (encoding) {\n                  case null:\n                  case undefined:\n                  case 'hex':\n                    pk.publicKeyHex = currentEvent.value.slice(2)\n                    break\n                  case 'base64':\n                    pk.publicKeyBase64 = Buffer.from(currentEvent.value.slice(2), 'hex').toString('base64')\n                    break\n                  case 'base58':\n                    pk.publicKeyBase58 = Base58.encode(Buffer.from(currentEvent.value.slice(2), 'hex'))\n                    break\n                  case 'pem':\n                    pk.publicKeyPem = Buffer.from(currentEvent.value.slice(2), 'hex').toString()\n                    break\n                  default:\n                    pk.value = currentEvent.value\n                }\n                pks[eventIndex] = pk\n                if (match[4] === 'sigAuth') {\n                  auth[eventIndex] = pk.id\n                }\n                break\n              }\n              case 'svc':\n                serviceCount++\n                services[eventIndex] = {\n                  id: `${did}#service-${serviceCount}`,\n                  type: algorithm,\n                  serviceEndpoint: Buffer.from(currentEvent.value.slice(2), 'hex').toString(),\n                }\n                break\n            }\n          }\n        }\n      } else {\n        if (\n          event._eventName === eventNames.DIDDelegateChanged ||\n          (event._eventName === eventNames.DIDAttributeChanged &&\n            (<DIDAttributeChanged>event).name.match(/^did\\/pub\\//))\n        ) {\n          delegateCount++\n        } else if (\n          event._eventName === eventNames.DIDAttributeChanged &&\n          (<DIDAttributeChanged>event).name.match(/^did\\/svc\\//)\n        ) {\n          serviceCount++\n        }\n        delete auth[eventIndex]\n        delete pks[eventIndex]\n        delete services[eventIndex]\n\n        if (event._eventName === eventNames.DIDOwnerChanged) {\n          if ((<DIDOwnerChanged>event).owner === nullAddress) {\n            deactivated = true\n            break\n          }\n        }\n      }\n    }\n\n    const doc: DIDDocument = {\n      ...baseDIDDocument,\n      verificationMethod: publicKeys.concat(Object.values(pks)),\n      authentication: authentication.concat(Object.values(auth)),\n    }\n    if (Object.values(services).length > 0) {\n      doc.service = Object.values(services)\n    }\n\n    return deactivated\n      ? { didDocument: { ...baseDIDDocument, '@context': 'https://www.w3.org/ns/did/v1' }, deactivated }\n      : { didDocument: doc, deactivated }\n  }\n\n  async resolve(\n    did: string,\n    parsed: ParsedDID,\n    _unused: Resolver,\n    options: DIDResolutionOptions\n  ): Promise<DIDResolutionResult> {\n    const fullId = parsed.id.match(identifierMatcher)\n    if (!fullId) {\n      throw new Error(`Not a valid ethr DID: ${did}`)\n    }\n    const id = fullId[2]\n    const networkId = !fullId[1] ? 'mainnet' : fullId[1].slice(0, -1)\n\n    if (!this.contracts[networkId])\n      throw new Error(`unknown_network: The DID resolver does not have a configuration for network: ${networkId}`)\n\n    const { controller, history, controllerKey, chainId } = await this.changeLog(id, networkId, options.blockTag)\n    try {\n      const { didDocument, deactivated } = this.wrapDidDocument(did, controller, controllerKey, history, chainId)\n      const status = deactivated ? { deactivated: true } : {}\n      return {\n        didDocumentMetadata: { ...status },\n        didResolutionMetadata: { contentType: 'application/did+ld+json' },\n        didDocument,\n      }\n    } catch (e) {\n      return {\n        didResolutionMetadata: {\n          error: 'notFound',\n          message: e.toString(), // This is not in spec, nut may be helpful\n        },\n        didDocumentMetadata: {},\n        didDocument: null,\n      }\n    }\n  }\n\n  build(): Record<string, DIDResolver> {\n    return { ethr: this.resolve.bind(this) }\n  }\n}\n"],"names":["identifierMatcher","DEFAULT_REGISTRY_ADDRESS","verificationMethodTypes","eventNames","legacyAttrTypes","sigAuth","veriKey","enc","legacyAlgoMap","Secp256k1VerificationKey2018","EcdsaSecp256k1VerificationKey2019","Ed25519SignatureAuthentication2018","Ed25519VerificationKey2018","Secp256k1SignatureAuthentication2018","RSAVerificationKey2018","X25519KeyAgreementKey2019","bytes32toString","input","Buffer","from","slice","toString","replace","stringToBytes32","str","buffStr","repeat","length","interpretIdentifier","identifier","address","computeAddress","publicKey","getAddress","knownNetworks","mainnet","ropsten","rinkeby","goerli","kovan","getContractForNetwork","conf","provider","web3","_conf$web","currentProvider","rpcUrl","Error","name","chainId","BigNumber","toNumber","networkName","_conf$name","JsonRpcProvider","ContractFactory","fromSolidity","DidRegistryContract","attach","registry","connect","configureNetwork","net","networks","configureNetworks","_conf$networks","reduce","EthrDidController","constructor","contract","signer","this","[object Object]","blockTag","functions","identityOwner","controller","currentOwner","getOwner","getSigner","newOwner","options","overrides","gasLimit","gasPrice","attachContract","ownerChange","changeOwner","wait","delegateType","delegateAddress","exp","delegateTypeBytes","addDelegateTx","addDelegate","startsWith","revokeDelegate","attrName","attrValue","undefined","setAttrTx","setAttribute","revokeAttributeTX","revokeAttribute","logDecoder","logs","map","log","logResult","result","eventFragment","inputs","args","TypeError","forEach","index","val","type","_eventName","populateEventMetaClass","interface","parseLog","getResolver","EthrDidResolver","build","contracts","projectId","infuraProjectId","InfuraProvider","Object","keys","configureResolverWithNetworks","networkId","changed","identity","hexChainId","chainIdFromNetwork","getNetwork","history","controllerKey","previousChange","newController","toLowerCase","blockNumber","events","getLogs","topics","fromBlock","toHexString","toBlock","reverse","event","unshift","lt","wrapDidDocument","did","baseDIDDocument","@context","id","verificationMethod","authentication","now","Math","floor","Date","getTime","publicKeys","EcdsaSecp256k1RecoveryMethod2020","blockchainAccountId","push","publicKeyHex","deactivated","delegateCount","serviceCount","auth","pks","services","validTo","eventIndex","delegate","value","gte","DIDDelegateChanged","currentEvent","DIDAttributeChanged","match","algorithm","encoding","pk","publicKeyBase64","publicKeyBase58","Base58","encode","publicKeyPem","serviceEndpoint","DIDOwnerChanged","owner","doc","concat","values","service","didDocument","parsed","_unused","fullId","changeLog","didDocumentMetadata","didResolutionMetadata","contentType","e","error","message","ethr","resolve","bind"],"mappings":"8kBAKaA,MAAAA,EAAoB,+CAEpBC,EAA2B,6CA+B5BC,IAAAA,EAQAC,GARZ,SAAYD,GACVA,wEACAA,sEACAA,0DACAA,kDACAA,wDALF,CAAYA,IAAAA,OAQZ,SAAYC,GACVA,oCACAA,4CACAA,0CAHF,CAAYA,IAAAA,OAiBCC,MAAAA,EAA0C,CACrDC,QAAS,8BACTC,QAAS,sBACTC,IAAK,uBAGMC,EAAwC,CAEnDC,6BAA8BP,EAAwBQ,kCAEtDC,mCAAoCT,EAAwBU,2BAE5DC,qCAAsCX,EAAwBQ,kCAE9DI,uBAAwBZ,EAAwBY,uBAChDF,2BAA4BV,EAAwBU,2BACpDG,0BAA2Bb,EAAwBa,oCAGrCC,EAAgBC,GAE9B,OADsC,iBAAVA,EAAqBC,OAAOC,KAAKF,EAAMG,MAAM,GAAI,OAASF,OAAOC,KAAKF,IACtFI,SAAS,QAAQC,QAAQ,OAAQ,aAG/BC,EAAgBC,GAC9B,MAAMC,EAAU,KAAOP,OAAOC,KAAKK,GAAKJ,MAAM,EAAG,IAAIC,SAAS,OAC9D,OAAOI,EAAU,IAAIC,OAAO,GAAKD,EAAQE,iBAG3BC,EAAoBC,GAClC,OAAIA,EAAWF,OAAS,GACf,CAAEG,QAASC,EAAeF,GAAaG,UAAWH,GAElD,CAAEC,QAASG,EAAWJ,IAIjC,MAQaK,OARuC,CAClDC,QAAS,MACTC,QAAS,MACTC,QAAS,MACTC,OAAQ,MACRC,MAAO,SClDT,SAASC,EAAsBC,SAC7B,IAAIC,EAAqBD,EAAKC,oBAAYD,EAAKE,aAALC,EAAWC,iBACrD,IAAKH,EAAU,CACb,IAAID,EAAKK,OAKP,UAAUC,0EAA0EN,EAAKO,MAAQP,EAAKQ,WALvF,OACf,MAAMA,EAAUR,EAAKQ,QAAUC,EAAU/B,KAAKsB,EAAKQ,SAASE,WAAaV,EAAKQ,QACxEG,EAAclB,EAAcO,EAAKO,MAAQ,aAAMP,EAAKO,aAALK,EAAW/B,QAAQ,UAAW,aAAe,MAClGoB,EAAW,IAAIY,EAAgBb,EAAKK,OAAQG,GAAWG,IAQ3D,OAH2BG,EAAgBC,aAAaC,GACrDC,OAAOjB,EAAKkB,UD5DuB,8CC6DnCC,QAAQlB,GAIb,SAASmB,EAAiBC,GACxB,MAAMC,EAA+B,GAC/Bd,EAAUa,EAAIb,SAAWf,EAAc4B,EAAId,MAAQ,IAUzD,OATIC,GACEa,EAAId,OACNe,EAASD,EAAId,MAAQR,EAAsBsB,IAG7CC,EAD8B,iBAAZd,OAA4BA,EAAQ5B,SAAS,MAAQ4B,GACxDT,EAAsBsB,KAC5BA,EAAIpB,UAAYoB,EAAInB,MAAQmB,EAAIhB,UACzCiB,EAASD,EAAId,MAAQ,IAAMR,EAAsBsB,IAE5CC,EAGT,SAASC,EAAkBvB,SACzB,YACKoB,EAAiBpB,YACjBA,EAAKsB,iBAALE,EAAeC,OAA2B,CAACH,EAAUD,SAC1CC,EAAaF,EAAiBC,IACzC,WCvFMK,EAKXC,YAAYvC,EAA8BwC,EAAoBC,GAC5DC,KAAKF,SAAWA,EAChBE,KAAKD,OAASA,EACd,MAAMxC,QAAEA,GAAYF,EAAoBC,GACxC0C,KAAKzC,QAAUA,EAGH0C,eAAC1C,EAAkB2C,GAE/B,kBAD0BJ,SAASK,UAAUC,cAAc7C,EAAS,CAAE2C,SAAAA,KACxD,GAGID,qBAACI,GACnB,MAAMC,EAAeD,QAAmBA,aAAwBE,SAASP,KAAKzC,QAAS,UACjFwC,EAASC,KAAKD,OAChBC,KAAKD,OACaC,KAAKF,SAAS3B,SAAUqC,UAAUF,IAAiBN,KAAKF,SAASC,OACvF,YAAYD,SAAST,QAAQU,GAGdE,kBAACQ,EAAmBC,EAAyB,IAE5D,MAAMC,KACJC,SAAU,OACVC,SAAU,KACPH,GAGCZ,aAAsBgB,eAAeH,EAAU/D,aAC9C+D,EAAU/D,KAEjB,MAAMmE,QAAoBjB,EAASK,UAAUa,YAAYhB,KAAKzC,QAASkD,EAAUE,GACjF,aAAaI,EAAYE,OAGVhB,kBACfiB,EACAC,EACAC,EACAV,EAAyB,IAEzB,MAAMC,KACJC,SAAU,OACVC,SAAU,KACPH,GAECZ,aAAsBgB,eAAeH,EAAU/D,aAC9C+D,EAAU/D,KAEjB,MAAMyE,EAAoBrE,EAAgBkE,GACpCI,QAAsBxB,EAASK,UAAUoB,YAC7CvB,KAAKzC,QACL8D,EACAF,EACAC,EACAT,GAGF,aAAaW,EAAcL,OAGThB,qBAClBiB,EACAC,EACAT,EAAyB,IAEzB,MAAMC,KACJC,SAAU,OACVC,SAAU,KACPH,GAELQ,EAAeA,EAAaM,WAAW,MAAQN,EAAelE,EAAgBkE,GAC9E,MAAMpB,aAAsBgB,eAAeH,EAAU/D,aAC9C+D,EAAU/D,KACjB,MAAM0E,QAAsBxB,EAASK,UAAUsB,eAC7CzB,KAAKzC,QACL2D,EACAC,EACAR,GAEF,aAAaW,EAAcL,OAGXhB,mBAChByB,EACAC,EACAP,EACAV,EAAyB,IAEzB,MAAMC,KACJC,SAAU,OACVC,SAAU,IACVR,gBAAYuB,GACTlB,GAELgB,EAAWA,EAASF,WAAW,MAAQE,EAAW1E,EAAgB0E,GAClEC,EAAYA,EAAUH,WAAW,MAAQG,EAAY,KAAOhF,OAAOC,KAAK+E,EAAW,SAAS7E,SAAS,OACrG,MAAMgD,aAAsBgB,eAAeH,EAAU/D,aAC9C+D,EAAU/D,KACjB,MAAMiF,QAAkB/B,EAASK,UAAU2B,aAAa9B,KAAKzC,QAASmE,EAAUC,EAAWP,EAAKT,GAChG,aAAakB,EAAUZ,OAGJhB,sBAACyB,EAAkBC,EAAmBjB,EAAyB,IAElF,MAAMC,KACJC,SAAU,OACVC,SAAU,KACPH,GAELgB,EAAWA,EAASF,WAAW,MAAQE,EAAW1E,EAAgB0E,GAClEC,EAAYA,EAAUH,WAAW,MAAQG,EAAY,KAAOhF,OAAOC,KAAK+E,EAAW,SAAS7E,SAAS,OACrG,MAAMgD,aAAsBgB,eAAeH,EAAU/D,aAC9C+D,EAAU/D,KACjB,MAAMmF,QAA0BjC,EAASK,UAAU6B,gBAAgBhC,KAAKzC,QAASmE,EAAUC,EAAWhB,GACtG,aAAaoB,EAAkBd,iBCnGnBgB,EAAWnC,EAAoBoC,GAM7C,OALgCA,EAAKC,IAAKC,GArB5C,SAAgCC,GAE9B,MAAMC,EAA8B,GACpC,GAAID,EAAUE,cAAcC,OAAOpF,SAAWiF,EAAUI,KAAKrF,OAC3D,UAAUsF,UAAU,oDAatB,OAXAL,EAAUE,cAAcC,OAAOG,QAAQ,CAACjG,EAAOkG,KAC7C,IAAIC,EAAMR,EAAUI,KAAKG,GACN,iBAARC,IACTA,EAAMlE,EAAU/B,KAAKiG,IAEJ,YAAfnG,EAAMoG,OACRD,EAAMpG,EAAgBoG,IAExBP,EAAO5F,EAAM+B,MAAQoE,IAEvBP,EAAOS,WAAaV,EAAU5D,KACvB6D,EAMSU,CADFlD,EAASmD,UAAUC,SAASd,cCI5Be,EAAYzC,GAC1B,WAAW0C,EAAgB1C,GAAS2C,cAGzBD,EAGXvD,YAAYa,GACVV,KAAKsD,mBHuEqCpF,EAA6B,IACzE,MAAMsB,QAvE6B+D,EAwEoBrF,EAAMsF,iBA7DtD/D,EAAkB,CAAED,SAPe,CACxC,CAAEf,KAAM,UAAWC,QAAS,MAAOP,SAAU,IAAIsF,EAAe,YAAaF,IAC7E,CAAE9E,KAAM,UAAWC,QAAS,MAAOP,SAAU,IAAIsF,EAAe,UAAWF,IAC3E,CAAE9E,KAAM,UAAWC,QAAS,MAAOP,SAAU,IAAIsF,EAAe,UAAWF,IAC3E,CAAE9E,KAAM,SAAUC,QAAS,MAAOP,SAAU,IAAIsF,EAAe,SAAUF,IACzE,CAAE9E,KAAM,QAASC,QAAS,OAAQP,SAAU,IAAIsF,EAAe,QAASF,OAPjE,GAuEJ9D,EAA8CvB,IAzErD,IAAqCqF,EA2EnC,GAAqC,IAAjCG,OAAOC,KAAKnE,GAAUpC,OACxB,UAAUoB,MAAM,iEAElB,OAAOgB,EG/EYoE,CAA8BlD,GAQnCT,eAAC1C,EAAiBsG,EAAmB3D,GAEjD,WAAWN,EAAkBrC,EAASyC,KAAKsD,UAAUO,IAAYtD,SAAShD,EAAS2C,GAQjED,qBAAC1C,EAAiBsG,EAAmB3D,GACvD,MAAMoC,aAAoBgB,UAAUO,GAAW1D,UAAU2D,QAAQvG,EAAS,CAAE2C,SAAAA,IAE5E,OAAOvB,EAAU/B,KAAK0F,EAAO,IAGhBrC,gBACb8D,EACAF,EACA3D,EAAqB,UAErB,MAAMJ,EAAWE,KAAKsD,UAAUO,GAC1B1F,EAAW2B,EAAS3B,SACpB6F,EAAaH,EAAUrC,WAAW,MAAQqC,EAAYlG,EAAckG,GAEpEI,SAA4B9F,EAAS+F,cAAcxF,QACnDA,EAAUsF,EAAarF,EAAU/B,KAAKoH,GAAYpF,WAAaqF,EAC/DE,EAA0B,IAC1B5G,QAAEA,EAAFE,UAAWA,GAAcJ,EAAoB0G,GACnD,IAAIK,EAAgB3G,EAChB4C,EAAa9C,EACb8G,aAA8CA,eAAe9G,EAASsG,EAAW3D,GAErF,GAAImE,EAAgB,CAClB,MAAMC,aAA2B/D,SAAShD,EAASsG,EAAW3D,GAC1DoE,EAAcC,gBAAkBlE,EAAWkE,gBAC7CH,OAAgBxC,GAElBvB,EAAaiE,EAEf,KAAOD,GAAgB,CACrB,MAAMG,EAAcH,EASdI,EAAyBxC,EAAWnC,QAPvB3B,EAASuG,QAAQ,CAClCnH,QAASuC,EAASvC,QAElBoH,OAAQ,CAAC,kCAA0CpH,EAAQV,MAAM,MACjE+H,UAAWP,EAAeQ,cAC1BC,QAAST,EAAeQ,iBAG1BJ,EAAOM,UACPV,EAAiB,KACjB,IAAK,MAAMW,KAASP,EAClBN,EAAQc,QAAQD,GACZA,EAAMX,eAAea,GAAGV,KAC1BH,EAAiBW,EAAMX,gBAI7B,MAAO,CAAEhE,WAAAA,EAAY8D,QAAAA,EAASC,cAAAA,EAAe1F,QAAAA,GAG/CyG,gBACEC,EACA/E,EACA+D,EACAD,EACAzF,GAEA,MAAM2G,EAA+B,CACnCC,WAAY,CACV,+BACA,+GAEFC,GAAIH,EACJI,mBAAoB,GACpBC,eAAgB,IAIZC,EAAM/G,EAAU/B,KAAK+I,KAAKC,OAAM,IAAIC,MAAOC,UAAY,MAEvDC,EAAmC,CACvC,CACER,MAAOH,eACPtC,KAAMnH,EAAwBqK,iCAC9B3F,WAAY+E,EACZa,uBAAwB5F,YAAqB3B,MAI3C+G,EAAiB,IAAIL,gBAEvBhB,IACF2B,EAAWG,KAAK,CACdX,MAAOH,kBACPtC,KAAMnH,EAAwBQ,kCAC9BkE,WAAY+E,EACZe,aAAc/B,IAEhBqB,EAAeS,QAAQd,oBAGzB,IAAIgB,GAAc,EACdC,EAAgB,EAChBC,EAAe,EACnB,MAAMC,EAA+B,GAC/BC,EAA0C,GAC1CC,EAA4C,GAClD,IAAK,MAAMzB,KAASb,EAAS,CAC3B,MAAMuC,EAAU1B,EAAM0B,SAAW/H,EAAU/B,KAAK,GAC1C+J,KAAgB3B,EAAMjC,cACLiC,EAAO9D,cAAsC8D,EAAOvG,QAClDuG,EAAO4B,UAAkC5B,EAAO6B,QACzE,GAAIH,GAAWA,EAAQI,IAAIpB,IACzB,GAAIV,EAAMjC,aAAenH,EAAWmL,mBAAoB,CACtD,MAAMC,EAAmChC,EAGzC,OAFAqB,IACqBW,EAAa9F,cAEhC,IAAK,UACHqF,EAAKI,MAAiBvB,cAAgBiB,IAExC,IAAK,UACHG,EAAIG,GAAc,CAChBpB,MAAOH,cAAgBiB,IACvBvD,KAAMnH,EAAwBqK,iCAC9B3F,WAAY+E,EACZa,uBAAwBe,EAAaJ,mBAAmBlI,cAIrDsG,EAAMjC,aAAenH,EAAWqL,oBAAqB,CAC9D,MAAMD,EAAoChC,EAEpCkC,EADOF,EAAavI,KACPyI,MAAM,+CACzB,GAAIA,EAAO,CACT,MACMC,EAAYD,EAAM,GAClBpE,EAAOjH,EAAgBqL,EAAM,KAAOA,EAAM,GAC1CE,EAAWF,EAAM,GACvB,OAJgBA,EAAM,IAKpB,IAAK,MAAO,CACVb,IACA,MAAMgB,EAA+B,CACnC9B,MAAOH,cAAgBiB,IACvBvD,QAASqE,IAAYrE,IACrBzC,WAAY+E,GAGd,OADAiC,EAAGvE,KAAO7G,EAAcoL,EAAGvE,OAASqE,EAC5BC,GACN,UACA,UAAKxF,EACL,IAAK,MACHyF,EAAGlB,aAAea,EAAaH,MAAMhK,MAAM,GAC3C,MACF,IAAK,SACHwK,EAAGC,gBAAkB3K,OAAOC,KAAKoK,EAAaH,MAAMhK,MAAM,GAAI,OAAOC,SAAS,UAC9E,MACF,IAAK,SACHuK,EAAGE,gBAAkBC,EAAOC,OAAO9K,OAAOC,KAAKoK,EAAaH,MAAMhK,MAAM,GAAI,QAC5E,MACF,IAAK,MACHwK,EAAGK,aAAe/K,OAAOC,KAAKoK,EAAaH,MAAMhK,MAAM,GAAI,OAAOC,WAClE,MACF,QACEuK,EAAGR,MAAQG,EAAaH,MAE5BL,EAAIG,GAAcU,EACD,YAAbH,EAAM,KACRX,EAAKI,GAAcU,EAAG9B,IAExB,MAEF,IAAK,MACHe,IACAG,EAASE,GAAc,CACrBpB,MAAOH,aAAekB,IACtBxD,KAAMqE,EACNQ,gBAAiBhL,OAAOC,KAAKoK,EAAaH,MAAMhK,MAAM,GAAI,OAAOC,oBAuB3E,GAfEkI,EAAMjC,aAAenH,EAAWmL,oBAC/B/B,EAAMjC,aAAenH,EAAWqL,qBACTjC,EAAOvG,KAAKyI,MAAM,eAE1Cb,IAEArB,EAAMjC,aAAenH,EAAWqL,qBACVjC,EAAOvG,KAAKyI,MAAM,gBAExCZ,WAEKC,EAAKI,UACLH,EAAIG,UACJF,EAASE,GAEZ3B,EAAMjC,aAAenH,EAAWgM,iBJrPjB,+CIsPK5C,EAAO6C,MAAuB,CAClDzB,GAAc,EACd,OAMR,MAAM0B,OACDzC,GACHG,mBAAoBO,EAAWgC,OAAOrE,OAAOsE,OAAOxB,IACpDf,eAAgBA,EAAesC,OAAOrE,OAAOsE,OAAOzB,MAMtD,OAJI7C,OAAOsE,OAAOvB,GAAUrJ,OAAS,IACnC0K,EAAIG,QAAUvE,OAAOsE,OAAOvB,IAGvBL,EACH,CAAE8B,iBAAkB7C,GAAiBC,WAAY,iCAAkCc,YAAAA,GACnF,CAAE8B,YAAaJ,EAAK1B,YAAAA,GAGbnG,cACXmF,EACA+C,EACAC,EACA1H,GAEA,MAAM2H,EAASF,EAAO5C,GAAG2B,MAAMzL,GAC/B,IAAK4M,EACH,UAAU7J,+BAA+B4G,KAE3C,MAAMG,EAAK8C,EAAO,GACZxE,EAAawE,EAAO,GAAiBA,EAAO,GAAGxL,MAAM,GAAI,GAAhC,UAE/B,IAAKmD,KAAKsD,UAAUO,GAClB,UAAUrF,sFAAsFqF,KAElG,MAAMxD,WAAEA,EAAF8D,QAAcA,EAAdC,cAAuBA,EAAvB1F,QAAsCA,cAAuB4J,UAAU/C,EAAI1B,EAAWnD,EAAQR,UACpG,IACE,MAAMgI,YAAEA,EAAF9B,YAAeA,GAAgBpG,KAAKmF,gBAAgBC,EAAK/E,EAAY+D,EAAeD,EAASzF,GAEnG,MAAO,CACL6J,yBAFanC,EAAc,CAAEA,aAAa,GAAS,IAGnDoC,sBAAuB,CAAEC,YAAa,2BACtCP,YAAAA,GAEF,MAAOQ,GACP,MAAO,CACLF,sBAAuB,CACrBG,MAAO,WACPC,QAASF,EAAE5L,YAEbyL,oBAAqB,GACrBL,YAAa,OAKnB7E,QACE,MAAO,CAAEwF,KAAM7I,KAAK8I,QAAQC,KAAK/I"}